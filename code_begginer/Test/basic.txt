
# 1) import math

    # print (math.ceil(pi))
    # print (math.floor(pi))
    # print (abs(pi))
    # print (pow(pi, 3)) # Возводит число в указанную степень
    # print(math.sqrt(pi)) # квадратный корень из числа

    print(max(pi, x, y, z))
    print(min(pi, x, y, z))

# 2) slicing = create a substring by extracting 
            elements from another string
        indexing[] or
        slice()
    
    [start:stop:step]
    
    name = 'Arthur Michael Zaitsev'
    # first_name = name[:6]
    # last_name = name[15:]
    funky_name = name[::1]
    reversed_name = name[::-1]

    print(reversed_name)

    website_1 = "https://google.com"
    website_2 = "https://wikipedia.com"
    slice = slice(8, -4)

    print(website_1[slice])
    print(website_2[slice])

# 3) if operator 
    age = int(input('how old are u, dude?'))

    if age >= 18:
        print('Come in! ')
    elif age < 0:
        print("Yo haven't been born yet!")
    else:
        print(age)

# 3) logical operator and, or, not = used to check if two or more conditional statements
    is true
    
    temp = int(input("Whats the temperature outside? "))

    # if temp >= 0 and temp <= 30:
    #     print("The temperature is good today! ")
    #     print("Go outside! ")
    # elif temp < 0 or temp > 30:
    #     print("Stay  home dear!")

    if not(temp >= 0 and temp <= 30):
        print("stay fckin inside")
    elif temp <= 30 or temp >= 0:
        print("Go outside, the weather is fine! ")

# 4) while loop = a statement that will execute its block of code,
    as long as its conditions

    # name = ""

    # while len(name) == 0:
    #     name = input("Enter Your name: ")
    # print('Hello ' + name + "! ")

    # the same w/ not operator

    name = None

    while not name:
    name = input("Enter Your name: ")
    print('Hello ' + name)

# 5) for loop = a statement that will execute its block 
    a limited amount of times

    for i in range(10+1):
    print(i)

    for i in range(50, 100+1, 2):
        print(i)

    for i in "Artem Michael Zaitsev":
        print(i)

    import time
    from typing import _SpecialForm
    for seconds in range(12, 0-1, -1):
        print(seconds)
        time.sleep(1)
    print("Happy new 2022!")

# 6) nested loops = the "inner loop" wil finish all of its iterations
    before finishing one iteration of the "outer loop"
    
    rows = int(input("How many rows? "))
    columns = int(input("How many columns? "))
    symbol = input("Input a symbol to use: ")

    for i in range(rows):
     for j in range(columns):
        print(symbol, end = "")
    print()

# 7) loop control statements = change a loop execution from its normal sequence

    # break    = used to terminate the loop entirely
    # continue = skips to the next iteration of the loop
    # pass     = does nothing, acts as a placeholder

    # while True:
    #     name = input("Input Your name, pls: ")
    #     if name != "":
    #         break

    # phone_number = "123-456-7890"
    # for i in phone_number:
    #     if i == "-":
    #         continue
    #     print(i, end="")

    # for i in range(1, 21):
    #     if i % 2:
    #         pass
    #     else:
    #         print(i)

# 8) list = used to store multiple items in a single variables
    # food = ["pizza", "burger", "meat", "spaghetti", "cake"]
    # food[0] = "rice"

    # food.append("ice-creame")
    # food.remove("burger")
    # food.pop()
    # food.insert(0, "apple")
    # food.sort()
    # food.clear()


    # print(food[0])

    # for x in food:
    #     print(x)

# 9) 2D list = a list of a lists

    drinks = ["cofee", "tea", "soda", "cola"]
    dinner = ["pizza", "humburger", "meat"]
    desert = ["cake", "ice-cream"]

    food = [drinks, dinner, desert]

    print(food[0][1])

# 10) tuple collection which is ordered and unchangeable
    used to group 2gether related data

    student = ("Artem", 32, "male")

    print (student.count("Artem"))

    print (student.index("male"))

    for x in student:
        print(x)
    if "Artem" in student:
        print("Artem is here! ")

# set = collection which is unordered, unidexed.
    NO duplicate values
    # utensils = {"fork", "spoon", "knife"}
    # dishes = {"bowl", "plate", "fork", "cup"}

    # dinner_table = utensils.union(dishes)

    # dishes.update(utensils)
    # utensils.add("napkin")
    # utensils.remove("fork")
    # utensils.clear()

    # for x in dinner_table:
    #     print(x)

    # print(utensils.difference(dishes))
    # print(utensils.intersection(dishes)) # находит общие значения

# dictionary =  A changeable, unordered collection of unique key:value pairs
    FAST cuz they do use hashing, allow us to access a value quickly

    capitals = {"USA": "Washington DC", 
    "India": "New Dehli",
    "China": "Beijin", "Russia": "Moscow"}

    print(capitals["USA"])
    print(capitals.get("Germany"))
    print(capitals.keys())
    print(capitals.values())
    print(capitals.items())



    capitals.update({"Germany":"Berlin"})
    capitals.update({"USA": "New York"})
    capitals.pop("China")


    for key, value in capitals.items():
        print(key, value)
    
# index operator [] = gives access to a sequence's element
    (str, tuple, list)
    name = "artem zaitsev!"
    # if (name[0].islower()):
    #     name = name.capitalize()

    first_name = name[0:5].capitalize()
    last_name = name[6:].capitalize()
    last_character = name[-1]

    print(first_name, last_name)
    print(last_character)

   
# function = a block of code which is executed ONLY WHEN IT's Called
    
    # name = "Artem"

    # def hello():
    #     print("Hello " + name)
    #     print("have a nice day!")

    # hello()

    # def hello(name):
    #     print("Hello " + name)

    # my_name = "Artem"
    # hello(my_name)

    def hello(name, sirname, age):
        print("Hello "+name+sirname)
        print("You are "+str(age)+" years old!")
        print("Have a nice day!")

    hello("Artem ", "Zaitsev ", 32)

# return statement = Functions send Python 
    values / objects back to the caller.
    These values / objects are known as the function's 
    return value.

    # def multiply (number_1, number_2):
    #     result = number_1 * number_2
    #     return(result)
    # x = multiply(3, 2)

    # print(x)   

    def multiply(number_1, number_2):
        return number_1 * number_2
    x = multiply(5, 2)

    print(x)

# keyword arguments = arguments proceded by an identifier
                      when we pas em to a function.
  The order of the arguments doesnt matter, unlike positional arguments
  Python knows the names of the arguments that our function receive.

      
    def hello(first_name, middle_name, last_name):
        print("Hello "+first_name+""+middle_name+""+last_name)
        # указываем в какой последовательности должны отобразиться аргументы

        # Присваиваем значения аргументам
    hello(first_name="Artem", last_name=" Zaitsev", middle_name=" Michael")

# nested Functions calls = function calls inside other calls
                           innermost function calls are resolved first
                           return value is used as argument for the next other function
    x = input("Enter the whole positive number: ")
    print(abs(round(float((x)))))

# Scope = the region that a variable is recognized
    A variable is only available from inside the region it is created.
    A global and locally  scoped versions of variable can be created

    name = "Senior" # global variable.
                # Availabele inside and outside of the function

    def display_name():
        name = "Artem" # loccal scope. Available only inside this function
        print(name)
    display_name()

    print(name)

    # L = Local локальный
    # E = Enclosing вложенный 
    # G = Global Глобальный
    # B = Built-in Встроенный

# * args = parameter that will pack all arguments into a tuple
    useful so that a function can accept a varying amount of arguments
    def add(*wea):
    sum = 0
    wea = list(wea)
    wea[0] = 0

    for i in wea:
        sum += i
    return sum

    print(add(123, 23, 21))

# ** kwargs = parameter that will pack all arguments into a dictionary
              useful so that a function can accept a varying amount of keyword argument
    def hello(**kwargs):
    print("Hello", end=" ")
    
    for key, value in kwargs.items():
        print(value, end=" ")

    hello(title="Mr.", first="Artem", second="Michael", third="Zaitsev")

# str.format() = optional method that gives users
                 more control when displaying output
    
    # animal = "cow"
    # item = "moon"

    # print("The " + animal + "jumped over the " + item)
    # print("the {} jumped over the {}!".format(animal, item))
    # print("the {1} jumped over the {0}!".format(animal, item)) # positional argument
    print("The {animal} jumped over the {item}!".format(animal="dog", item="bench")) # keyword argument
    
    # animal = "cat"
    # item = "chair"

    # text = ("The {} jumped over the {}!")
    # print(text.format(animal, item))

    # name = "Artem"
    # sirname = "Zaitsev"

    # print("Hey, my name is {}!".format(name))
    # print("Hey, my name is {:10}!".format(name)) # Добавляет пустое пространство!
    # print("Hey, my name is {:<10}!".format(name)) # Добавляет пустое пространство слева!
    # print("Hey, my name is {:>10}!".format(name)) # Добавляет пустое пространство справа!
    # print("Hey, my name is {:^10}!".format(name)) # по центру

    # print("Hey, my name is {:^10}!".format(sirname))

    # number = 3.14159
    # print("the number pi is {}".format(number))
    # print("the number pi is {:.4f}".format(number)) # сколько знаков после точки. Округляется значение


    # number = 100000
    # print("the number is {:,}".format(number))
    # print("the number is is {:b}".format(number)) # b = binary 
    # print("the number is is {:o}".format(number)) # o = octal
    # print("the number is is {:x}".format(number)) # x = hex lower case
    # print("the number is is {:X}".format(number)) # X = HEX UPPER case
    # print("the number is is {:e}".format(number)) # e = scienfic notation
    
# import random

    import math
    from random import randint
    import random

    x = str(random.randint(0, 100))
    y = str(random.random())

    my_list = ["rock", "paper", "scissors"]
    z = random.choice(my_list)

    cards = [1, 2, 3, 4, 5, 6, 7, 8, 9, "J", "Q", "K", "A"]
    random.shuffle(cards)

    print(cards)
    
# exception = events detected during  execution that interrupt the flow of program  
    def proga(*args):
        
        try:
            numerator = int(input("enter a number to devide "))
            denominator = int(input("Enter a number to devide by "))

            result = numerator / denominator

        except ZeroDivisionError as e:
            print(e)
            print("You cant devide by zero! ")

        except ValueError as e:
            print(e)
            print("Enter only numbers, pls")

        except Exception as e:
            print(e)
            print("smt went wrong ")
        else:
            print(result)
        finally:
            print(proga())
    print(proga())

# file detection work w/ files
    import os

    path = "C:\\Users\\Артём\\Desktop\\Test\\Hot_keys.txt"
    if os.path.exists(path):
        print('This paths exists!')
        if os.path.isfile(path):
            print("it's a file, the to open it!!")
        elif os.path.isdir(path):
            print("HTats a dir")
    else:
        print("no path with this name!!")

    
    try:
        with open('Hot_keys.tt') as file:
            print(file.read())

    except FileNotFoundError:
        print("That file was not found! ")

    text = "See ya!"

    with open("test.txt", "a") as file:
        file.write(text)
    with open("test.txt") as file:
        print(file.read())

# Copying files 
    copyfile() = copies content of a file
    copy() = copyfile() + permission mode + destination can be a drink
    copy2() = copy() + copies metadata (files creation & modification times)

    import shutil

    shutil.copyfile("test.txt", "copy_test.txt") # 2 args src & destination

# moving files
    import os

    source = "test.txt"
    destination = "C:\\Users\\Артём\Desktop\\google-api\\test.txt"

    try:
        if os.path.exists(destination):
            print("there is already a file there ")
        else:
            os.replace(source, destination)
            print(source+"was moved!")
    except FileNotFoundError:
        print(source+"not found")

    # deleting files
    import os
    import shutil


    path = "Empty_folder"

    try:
        # os.remove(path) # DELETE FILE
        # os.rmdir(path) # DELETE FOLDER
        shutil.rmtree(path) # DELETE EMPTY FOLDER

    except FileNotFoundError:
        print("This file does not exist!")
    except PermissionError:
        print("NO permission to this folder!")
    except OSError:
        print("This folder is not empty!\nYou can't delete that using that function\n" +"Use shutil module")
    else:
        print(path+ " was deleted!")

# modules
    module is a file that contains python code.
    May contain functions, classes, etc.,
    Used w/ modular programming, which is to separate a program into parts

# game paper, rock, scissors
    import random

    while True:
        choices = ["paper", "rock", "scissors"]
        computer = random.choice(choices)
        player = None

        while player not in choices:
            player = input("paper, rock, or scissors? ").lower()

        if player == computer:
            print("Computer: ", computer)
            print("Player: ", player)
            print("Tie!")
        elif player == "rock":
            if computer == "paper":
                print("Computer: ", computer)
                print("Player: ", player)
                print("You loose")
            if computer == "scissors":
                print("Computer: ", computer)
                print("Player: ", player)
                print("You Win!")
        elif player == "scissors":
            if computer == "paper":
                print("Computer: ", computer)
                print("Player: ", player)
                print("You Win!")
            if computer == "rock":
                print("Computer: ", computer)
                print("Player: ", player)
                print("You loose!")
        elif player == "paper":
            if computer == "scissors":
                print("Computer: ", computer)
                print("Player: ", player)
                print("You loose")
            if computer == "rock":
                print("Computer: ", computer)
                print("Player: ", player)
                print("You Win!")
        play_again = input("Wanna play again? (Yes / No)").lower()
        if play_again != "yes":
            break
    print("Good bye!")

# game qwizz

        def new_game():
        answers = []
        correct_answers = 0
        question_num = 1

        for key in questions:
            print("_____________________\n")
            print(key)
            for i in options[question_num-1]:
                print(i)
            guess = input("Enter A, B, C, D :\n")
            guess = guess.upper
            answers = answers.append(guess)

            correct_answers += check_answer(questions.get(key), guess)

            question_num += 1

        display_scores(correct_answers, answers)

    #//////////////////////////////////////////

    def check_answer(otvet, guess):
        if otvet == guess:
            print("Correct")
            return 1
        else:
            print("Wrong!")
            return 0
    #//////////////////////////////////////////

    def display_scores(correct_answers, answers):
        print("_____________________\n")
        print("Results")
        print("_____________________\n")
        print("Answers: ", end="")
        for i in questions:
            print(questions.get(i), end="")
            print()

        print("Guesses: ", end="")
        for i in answers:
            print(i, end="")
            print()    

    #//////////////////////////////////////////

    def play_again():
        pass
        
    questions = {
        "Who created Python?: " : "A",
        "What year was Python created?: " : "B",
        "Python is tributed to which group?: " : "C",
        "Is the Earth round?: " : "A"
    }

    options = [["A. Guido van R", "B. Elon Musk", "C. Bill Gates", "D. Mark Zuckerberg"],
            ["A. 1989 year", "B. 1991 year", "C. 2000 year", "D. 2016 year"],
            ["A. Lonely Island", "B. Smosh", "C. Monthy Python", "D. SNL"],
            ["A. True", "B. False", "C. Sometimes", "D. Which Valentina?"]]

    new_game()

# POOP
    from  car import Car

    car_1 = Car("Жигулян", "Шиха", 2000, "Черная")
    car_2 = Car("Lada-Sedan", "Priora", 2010, "Баклажан")

    print(car_1.make)

    car_1.drive()
    car_2.stop()

    class Car:
    def __init__(self, make, model, year, color):
        self.make = make
        self.model = model
        self.year = year
        self.color = color

    def drive(self):
        print("Эта "+self.make+" хуярит 300 кмч")
    def stop(self):
        print("Короче мусора тормознули эту "+self.make, self.color)

# Difference between class variable & instance variable

    from car import Car

    car_1 = Car("Chevy", "Chevrolette", 2000, "Yellow")
    car_2 = Car("Ford", "Mustang", 2001, "Red")

    print(car_2.wheels) # Обращается к class 


    car_2.wheels  = 2   
    print(car_2.wheels) # Обращается к class, 
                        # но мы перезаписали значение для конкретной переменной

    print(Car.wheels)

    Car.wheels = 5 # Меняет значение у всего класса
    print(Car.wheels)

    class Car:
    
    wheels = 4  # class variable

    def __init__(self, make, model, year, color):
        self.make = make    # instance variable inside the constructor
        self.model = model  # instance variable
        self.year = year    # instance variable
        self.color = color  # instance variable

# Inheritance Python
    class Animal:

    alive = True

    def eat(self):  # создаем методы типа глаголы
        print("This animal is eating")

    def slumber(self):
        print("This animal is sleeping")

    class Rabbit(Animal):   # child class
        def run(self):
            print("This rabbit is running")
    class Fish(Animal):     # child class
        def swim(self):
            print("This fish is swimming")
    class Hawk(Animal):     # child class
        def fly(self):
            print("This hawk is flying")

    rabbit = Rabbit()       # создали объект//переменную, которая ссылается на класс
    fish = Fish()
    hawk = Hawk()

    # print(rabbit.alive)

    # fish.eat()
    # hawk.slumber()
    print("____________\n")

    rabbit.run()
    fish.swim()
    hawk.fly()

    print("____________\n")

# multy-level Inheritance = when a derived(child) class inherits 
                            another derived child class.
    class Organism:
        alive = True

    class Animal(Organism):
        def eat(self):
            print("This animal is eating")

    class Dog(Animal):
        def bark(self):
            print("This dog is barking")
        
    dog = Dog()

    print(dog.alive)
    dog.eat()
    dog.bark()

# multiple inheritance = whe a child is derived from more than one parent

    class Prey:
    def flee(self):
        print("This animal flees")
        
    class Predator:
        def haunt(self):
            print("This animal haunting")

    class Rabbit(Prey):
        pass

    class Hawk(Predator):
        pass

    class Fish(Prey, Predator): # multiple inheritance наследует классы
                                # двух родителей сразу, имеет доступ к 
                                # методам обоих
        pass

    rabbit = Rabbit()
    hawk = Hawk()
    fish = Fish()

    rabbit.flee()
    hawk.haunt()
    fish.haunt()
    fish.flee() 

# overwriting

    class Animal:
    def eat(self):
        print("This animal is eating")
        
    class Rabbit(Animal):
    def eat(self):
        print("This rabbit is eating a carrot") # переписали метод
                                                # для более узкого описания

    rabbit = Rabbit()
    rabbit.eat()

# method chaining = calling multiple methods sequentially
                    each call performs an action on the same object 
                    & returns self 
                    # вызывает все методы поочереди

    class Car:
    
    def turn_on(self):
        print("You turn on the engine")
        print("_____________________\n")
        return self
    
    def drive(self):
        print("You drive the car")
        print("_____________________\n")
        return self

    def brake(self):
        print("You step on the brakes ")
        print("_____________________]\n")
        return self

    def turn_off(self):
        print("You turned off the engine")
        print("_____________________\n")
        return self

    car = Car()
    car.turn_on().drive().brake().turn_off()

# super () = Function use to give access to the methods 
             of a parent class.
             Returns a temporary object of a parent class
             when used.
    
    class Rectangle:
    
    def __init__(self, length, width): # __init__ метод который будем реюзать
        self.length = length
        self.width = width


    class Square(Rectangle):

    def __init__(self, length, width):
        super().__init__(length, width)

    def area(self):
        return self.length*self.width
        

    class Cube(Rectangle):

    def __init__(self, length, width, height):
        super().__init__(length, width)
        self.height = height

    def volume(self):
        return self.length*self.width*self.height

    square = Square(3, 3)
    cube = Cube(3, 3, 3)
    print(square.area())
    print(cube.volume())

# abc 
    prevents user from creating an object of that class
    + compels a user to override abstract methods in a child class

    abstract classe = a class which contains one ore more 
                      abstract methods
    
    abstract method = a method that has a declaration 
                      but does not have an implementation

    from abc import ABC, abstractmethod

    class Vehicle(ABC):
        
        @abstractmethod
        def go(self):
            pass
            
        @abstractmethod
        def stop(self):
            pass

    class Car(Vehicle):
        
        def go(self):
            print("You drive the car")

        def stop(self):
            print("This motorcycle is stopped")

    class Motorcycle(Vehicle):
        
        def go(self):
            print("You drive motorcycle")

        def stop(self):
            print("This motorcycle is stopped")

    car = Car()
    car.go()

    motorcycle = Motorcycle()
    motorcycle.stop()

# How to pass objects like arguments
    class Car:
        
        color = None
        
    class Motorcycle:
        
        color = None

    def change_color(vehicle, color):
        vehicle.color = color

    car_1 = Car()
    car_2 = Car()
    car_3 = Car()
    bike_1 = Motorcycle()

    # Тут нужно вызвать написанную функцию, чтобы задать значение
    change_color(car_1, "Red")
    change_color(car_2, "green")
    change_color(car_3, "yellow")
    change_color(bike_1, "Black")

    print(car_1.color)
    print(car_2.color)
    print(car_3.color)
    print(bike_1.color)

# Duck typing = concept where the class of an object is less important
                than the methods.
                Class type is not checked if minimum methods/attributes
                are present.
                
                "If it walks like a duck, and it quacks like a duck,
                than it must be a duck!"   
    class Duck:

    def walk(self):
        print("THis duck is walkking")
    
    def talk(self):
        print("This duck is quacking")

    class Chicken:

        def walk(self):
            print("this chicken is walking")

        def talk(self):
            print("This chicken is qlucking")

    class Person():
        
        def catch(self,duck):
            duck.walk()
            duck.talk()
            print("you grab this gritter")

    duck = Duck()
    chicken = Chicken()
    person = Person()

    person.catch(duck)
    person.catch(chicken)

# walrus operator :=
    assignment expression aka walrus operator
    assigns values to variables as part orf a larger expression

        foods = list()

        while food := input("EWnter some food") != "quit":
            foods.append(food)

    foods = list()
    while True:
        food = input("name some food u like ")
        if food == "q":
            break
        foods.append(food)
        print(foods)
    print(foods)

    foods = list()

    while food := input("enter some food ") != "q" : foods.append(food)

# functions to variables
    def hello():
    print("Hello")

    hello()
    print(hello) # address in memory
    hi = hello
    print(hi)

    hello()
    hi()

    say = print
    say("Hi")

# Higher order function = a function that either:
    
    1. accepts a function as an argument
    2. returns a functions
    (in Python functions are also treated as objects)
    def loud(text):
        return text.upper()

    def quiet(text):
        return text.lower()

    def hello(func):
        text = func("aosd")
        print(text)

    hello(loud)

    def delitel(x):
        def delimoe(y):
            return y / x
        return delimoe

    devide = delitel(2)
    print(devide(10))

# lambda function = function written in one line using lambda keyword
                    accepts any number of arguments, 
                    but only have one expression
                    (think of it as a shortcut)
                    (useful if needed for a short period of time, throw away)

    double = lambda x:x * 2
    multiply = lambda x, y, z: x * y * z

    print(double(22))
    print(multiply(2, 3, 4))

    full_name = lambda first_name, mid_name, last_name: first_name + " " + mid_name + " " + last_name
    print(full_name("Artem", "Michael", "Zaitsev"))

    age_check = lambda age:True if age >= 18 else False
    print(age_check(18)) 

# sortirovka 

    sort() method   = used with lists
    sort() function = used with iterables

    students = [("Squidward", "F", 60),
            ("Sandy", "A", 33),
            ("Patrick", "D", 36),
            ("Spongebob", "B", 20),
            ("Mr. Crabs", "C", 78)]

    grade = lambda grades:grades[1]
    students.sort(key=grade)

    for i in students:
        print(i)
    print("======================")
    students = (("Squidward", "F", 60),
            ("Sandy", "A", 33),
            ("Patrick", "D", 36),
            ("Spongebob", "B", 20),
            ("Mr. Crabs", "C", 78))

    age = lambda ages:ages[2]
    sorted_students = sorted(students, key=age, reverse=True)

    for i in sorted_students:
        print(i)

# sort bubble method

    mas = list(map(int, input().split()))
    count = 0

    for run in range(n-1):
        for i in range(n-1):
            print(f"сейчас сравниваем {mas[i]} c {mas[i+1]} ")
            if mas[i] > mas[i+1]:
                count +=1
                mas[i], mas[i+1] = mas[i+1], mas[i]
    for i in mas:
        print(i, end=" ")
        print(mas)

    print()
    print(count)

# sort quick_sort method

    def quick_sort(s):

        if len(s)<=1:
            return s

        elem = s[0]
        left = list(filter(lambda x: x<elem, s))
        center = [i for i in s if i==elem]
        right = list(filter(lambda x: x>elem, s))

        return quick_sort(left) + center + quick_sort(right)

    print(quick_sort([7, 6, 10, 5, 9, 8, 3, 4]))

# map() function = applies a function to each item in an iterable
                    (lis, tuple, etc)
    map(function, iterable)

    store = [("shirt", 20.00),
         ("pants", 25.00),
         ("jacket", 50.00),
         ("socks", 10.00)]

    to_euros = lambda data: (data[0], data[1]*0.82)
    store_euros = list(map(to_euros, store))

    for i in store_euros:
        print(i)

    store = [("shirt", 20.00),
            ("pants", 25.00),
            ("jacket", 50.00),
            ("socks", 10.00)]


    to_rubles = lambda data: (data[0], data[1]*73)

    store_rubles = list(map(to_rubles, store))

    for i in store_rubles:
        print(i)

# filter() = creates collection of elements from an iterable
             for which a function returns true

    filter(function, iterable)

    friends = [("Rachel", 19),
            ("Joe", 16),
            ("Phoebe", 17),
            ("Chandler", 21),
            ("Monica", 20),
            ("Ross", 18)]
        
    age = lambda data: data[1] >= 18

    adult_friends = list(filter(age, friends))

    for i in adult_friends:
        print(i)

# reduce() = apply a function to an iterable and reduce it to
             a single comulative value.

             performs function on first two elements and repeats
             process until 1 value remains
  
  reduce(function, iterable)

    import functools
    from typing import OrderedDict

    letters = ["H", "H", "H", "H", "H", "H" ]
    word = functools.reduce(lambda x, y: x+y, letters)

    print(word)

    factorial = [5, 4, 3, 2, 1]

    result = functools.reduce(lambda x, y: x*y, factorial)
    print(result)

# list comprehension = a way to create a new list w/ less syntax
                       can mimic certain lamda function, easier to read
                       
                       порядок записи
                       list = [expression for item in iterable]
                       list = [expression for item in iterable if conditional]
                       list = [expression if/else for item in iterable]
    squares = []                    # create an empty list
    for i in range(1, 11):          # crate a for loop
    squares.append(i * i)        # define what each loop iteration should do
        

    print(squares)


    squares_1 = [ i*i for i in range (1, 11)]
    print(squares_1)

    students = [100, 90, 80, 70, 60, 50, 40, 30, 0]

    passed_students = [i for i in students if i >= 60]

    passed_students = [i if i >= 60 else "Failed" for i in students ]

    print(passed_students)

# dictionary comprehension = create dictionary using an expression
                             can replace for loop and certain lamda Function

    1) dictionary = {key: expression for (key, value) in iterable}
    2) dictionary = {key: expression for (key, value) in iterable if conditional}
    3) dictionary = {key: (if/else)  for (key, value) in iterable}
    4) dictionary = {key: function(value) for (key, value) in iterable}

    -------------------------------------------------------------------

    1)
    cities_in_F = {"Ney York": 32, "Boston": 75, "Los Angeles": 100, "Chicago": 50}
    cities_in_C = {key: round((value-32)*(5/9)) for (key:value) in cities_in_F.items()}
    

    cities = {"Ney York": 32, "Boston": 75, 
          "Los Angeles": 100, "Chicago": 50}
    3) 
    desc_weather = {key: ("is warm today" if value >=75 else "is cold today") for(key, value) in cities.items()}
    print(desc_weather)
        print(cities_in_C)
    
    4)
    from functools import reduce


    cities = {"Ney York": 32, "Boston": 75, 
            "Los Angeles": 100, "Chicago": 50}

    def check_temp(value):
        if value >= 70:
            return "Hot"
        elif 69 >= value >= 40:
            return "Warm"
        else:
            return "Cold"

    desc_weather = {key: check_temp(value) for (key, value) in cities.items()}
    print(desc_weather)

# zip(* iterable) = aggregate elements from two or more iterables(list, tuples, sets, etc...)
                    creates a zip object with paired elements stored
                    in tuples for each element

    # usernames = ["Dude", "Bro", "Mister"]
    # passwords = ("p@ssword", "abc123", "guest")

    # users = dict(zip(usernames, passwords))

    # for key, value in users.items():
    #     print(key+" : "+value)

    usernames = ["Dude", "Bro", "Mister"]
    passwords = ("p@ssword", "abc123", "guest")
    login_dates = ["1/1/2021", "1/2/2021", "1/3/2021" ]

    users = zip(usernames, passwords, login_dates)

    for i in users:
        print(i)

# main 

    python interpreter sets "special variables",
    one of which is __name__

    python will assign the __name__ variable a value of "__main__"
    if it's initial module beign run

    y tho?
    1. Module can be run as standalone program
    2. Module can be imported and used by other modules

    # if __name__ == '__main__':
    #     print('This module is running directly')
    # else:
    #     print('This module is imported')

    def  hello():
        print("Hello")
    
    if __name__ == "__main__":
        hello()


        import module_one

        module_one.hello()

# time 

    import time

    print(time.ctime(time.time()))

    time_object = time.localtime()
    print(time_object)

    utc_time = time.gmtime()
    print(utc_time)

    local_time = time.strftime("%B %D %Y %H:%M%S", time_object)
    print(local_time)

# thread = a flow of execution. Like a separate order of instructions.
            However each thread takes a turn running to achieve concurrency
            GIL = (Global interpreter Lock)

            allows only one thread to hold the control of the Python interpreter

    # cpu bound = program/task spends most of its time 
                waiting for internal events(CPU intensive)
                use muktiprocessing

    # io bound  = program/task spends most of its time 
                waiting for external events(user input, web scrapping)
                use multithreading

              
    import threading
    import time

    def eat_breakfast():
        time.sleep(3)
        print("You eat breakfast")

    def drink_cofee():
        time.sleep(4)
        print("You drink coffee")

    def study():
        time.sleep(5)
        print("You are studying")

    x = threading.Thread(target=eat_breakfast, args=())
    x.start()

    y = threading.Thread(target=drink_cofee, args=())
    y.start()

    z = threading.Thread(target=study, args=())
    z.start()

    x.join()
    y.join()
    z.join()

    # eat_breakfast()
    # drink_cofee()
    # study()

    print(threading.active_count())
    print(threading.enumerate())
    print(time.perf_counter())

# Daemon threads

    a thread that runs in the background, not important for program 
    to run your program will not for daemon theads to complete before exiting
    non-daemon threads cannot normally be killed, stay alive until task complete

    ex.background task, garbage collection, waiting for input, long running process

    import threading
    import time

    def timer():
        print()
        count = 0
        while True:
            time.sleep(1)
            count += 1
            print("Logged in for ", count, "seconds")

    x = threading.Thread(target=timer, daemon=True)
    x.start()

    print(x.isDaemon())

    answer = input("Do u wish to exit?\n")

# Python multiprocessing


# Gui

    from tkinter import *
    import webbrowser

    if __name__ == "__main__":
        import webbrowser

    button_clicked_count = 0
    def click():
        global button_clicked_count
        button_clicked_count+=1
        print(button_clicked_count)
        webbrowser.open_new(r"https://market.yandex.ru/")


    shwindow = Tk() # instatiate an instance of a window 
    shwindow.geometry("300x300")
    shwindow.title("GUI first")

    icon = PhotoImage(file="python.png")
    shwindow.iconphoto(True, icon)
    shwindow.config(background="#fff", padx=500)

    photo = PhotoImage(file="photo.png")

    label = Label(shwindow, text="Проверка цен на Яндекс Маркет", 
                            font=("Open Sans", 30, "bold"), 
                            fg="#282A36", bg="#fff", bd=0,
                            relief=RAISED,
                            compound="bottom",
                            padx=20, pady=20,
                            image=photo,
                            )

    # entry = Entry(shwindow,
    #               font=("Open Sans", 25))
    # entry.pack(side=LEFT)

    button = Button(shwindow, 
                    text="Парсить Yandex Market",
                    command=click,
                    font=("Open Sans", 18, "bold"),
                    fg="#282A36", bd=0, bg="#fafafa",
                    activeforeground="#282A36",
                    activebackground="#fafafa",
                    compound="bottom")

    shwindow.mainloop() 
    # place window in computer screen/

    button.pack()        
    # shwindow это название окна. 
    # Впервую очередь мы образаемся к нему, 
    # а потом пишем все параметры

    label.pack()
    # label.place() позволяет задать координаты x, y =

# GUI 2
    from tkinter import *

    def submit():
        username = entry.get()
        print("Hello ", username)
        entry.config(state=DISABLED)

    def delete():
        entry.delete(0, END)

    def backspace():
        entry.delete(len(entry.get())-1, END)

    window = Tk()
    window.geometry("360x260")
    window.title("Test")

    entry = Entry(window, font=("Open Sans", 24, "bold"),
                fg="#D0FF00", 
                bg="#000",
                show="*")

    entry.insert(0, "Default Text")
    entry.pack(side=LEFT)

    submit_button = Button(window, text="Submit", command=submit)
    submit_button.pack(side=RIGHT)

    delete_button = Button(window, text="Delete", command=delete)
    delete_button.pack(side=RIGHT)

    backspace_button = Button(window, text="Backspace", command=backspace)
    backspace_button.pack(side=RIGHT)

    window.mainloop()

# check buttons
        from tkinter import *

    def display():
        if(x.get()):
            print("You agree!")
        else:
            print("You do not agree!")

    window = Tk()

    x = BooleanVar()

    python_photo = PhotoImage(file="python.png")

    check_button = Checkbutton(window, text="I agree to smth. ",
                            font=("Open Sans", 12, "bold"),
                            variable=x,
                            onvalue=True, offvalue=False,
                            command=display,
                            fg="#282A36", bg="#FFF",
                            activebackground="#FFF",
                            activeforeground="#282A36",
                            padx=35, pady=35,
                            image=python_photo, compound="right")

    check_button.pack()

    window.mainloop()

# openfile dialog
    from tkinter import *
    from tkinter import filedialog

    def open_file():
        file_path = filedialog.askopenfilename(initialdir='C:\\Users\\Артём\\Desktop\\Test',
                                            title='open file, ok?',
                                            filetypes = (('text files', '*.txt'),
                                            ('all files', '*.*')))
        file = open(file_path, 'r')
        print(file.read())
        file.close()


    window = Tk()
    button = Button(window, text='Open', command=open_file)
    button.pack()

    window.mainloop()

# saving file gui tkinter
    from tkinter import *
    from tkinter import filedialog

    def save():
        save_file = filedialog.asksaveasfile(initialdir="C:\\Users\\Артём\\Desktop\\Test",
                                            defaultextension='.txt',
                                            filetypes=[
                                            ('Text file', '.txt'),
                                            ('HTML', '.html'),
                                            ('All types', '.*')])

        if save_file is None:
            return

        file_text = str(text.get(1.0, END))
        save_file.write(file_text)
        save_file.close()

    window = Tk()

    button = Button(window, text='Save', command=save)
    button.pack()

    text = Text(window)
    text.pack()

    window.mainloop()

# frame = a rectangular container to group and hold widgets

from tkinter import *

    window = Tk()

    frame = Frame(window, bg="#FF00AE", border=5, relief=SUNKEN)
    frame.place(x=0, y=0)

    Button(frame, text="W", font=('Consolas', 25, "bold"), width=3).pack(side=TOP)
    Button(frame, text="A", font=('Consolas', 25, "bold"), width=3).pack(side=LEFT)
    Button(frame, text="S", font=('Consolas', 25, "bold"), width=3).pack(side=LEFT)
    Button(frame, text="D", font=('Consolas', 25, "bold"), width=3).pack(side=LEFT)


    window.mainloop()

# how to create new windows

    from tkinter import *

    def create_window():
        new_window = Tk() # new independant window
        # new_window = Toplevel() # new window on top of other windows, linked to a bottom window
        old_window.destroy() # close out of old window


    old_window = Tk()

    Button(old_window, text="Create new window", command=create_window).pack()

    old_window.mainloop()
# grid() = geometry manager that organizes widgets in a table-like structure in a parent container 

    from tkinter import *

    window = Tk()

    label_1 = Label(window, text='Enter ur info', fg='#FF00AE', font=('Arial', 25)).grid(row=0, column=0, columnspan=2)

    first_name_label = Label(window, text='First name').grid(row=1, column=0)
    first_name_entry = Entry(window).grid(row=1, column=1)

    last_name_label = Label(window, text='Last name').grid(row=2, column=0)
    last_name_entry = Entry(window).grid(row=2, column=1)

    email = Label(window, text='Email address').grid(row=3, column=0)
    email_entry = Entry(window).grid(row=3, column=1)

    submit_button = Button(window, text='Submit').grid(row=4, column=0, columnspan=2)

    window.mainloop() 

# GUI window events 
    keys
    
    from tkinter import *

    def doSmth(event):
        label.config(text=event.keysym, pady=100)

    window = Tk()

    window.bind("<Key>", doSmth)

    label = Label(window, font=('Helvetica', 100))
    label.pack()

    window.mainloop()

# GUI window events
    mouse
    from tkinter import *

    def dosmth(event):
        print("Your mouse is now at " + str(event.x) + "," + str(event.y))

    window = Tk()

    # window.bind("<Button-1>", dosmth)
    # window.bind("<Button-2>", dosmth) # scroll button
    # window.bind("<Button-3>", dosmth)
    # window.bind("<ButtonRelease>", dosmth)
    # window.bind("<Enter>", dosmth)
    # window.bind("<Leave>", dosmth)
    # window.bind("<Motion>", dosmth)

    window.mainloop()

# drag and drop widgets
    from tkinter import *

    def drag_start(event):
        widget = event.widget
        widget.start_x = event.x
        widget.start_y = event.y

    def drag_motion(event):
        widget = event.widget
        x = widget.winfo_x() - widget.start_x + event.x
        y = widget.winfo_y() - widget.start_y + event.y
        widget.place(x=x, y=y)


    window = Tk()

    label = Label(window, bg='#FF00AE', widt=10, height=5)
    label.place(x=0, y=0)

    label2 = Label(window, bg='#D0FF00', widt=10, height=5)
    label2.place(x=100, y=100)


    label.bind("<Button-1>", drag_start)
    label.bind("<B1-Motion>", drag_motion)

    label2.bind("<Button-1>", drag_start)
    label2.bind("<B1-Motion>", drag_motion)

    window.mainloop()

#
